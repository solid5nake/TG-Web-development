<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../../../dark.css">
  <title>Functions</title>
</head>

<body class="pl-5">
  <nav>
    <div class="breadcrumbs" id="up">
      <a href="../index.html">Javascript</a>
      <a href="../intro/1.html">Introduction I</a>
      <a href="../intro/2.html">Introduction II</a>
      <a href="../conditions/1.html">Conditions I</a>
      <a href="../conditions/2.html">Conditions II</a>
      <a href="./1.html" class="active">Functions 1 - 7</a>
      <a href="./8.html">Functions 8</a>
      <a href="../arrays/1.html">Arrays</a>
      <a href="../scopes/1.html">Scopes</a>
      <a href="../loops_iterators/1.html">Loops & iterators</a>
      <a href="../objects/1.html">Objects</a>
      <a href="../final_assignment/calculator.html">Final Assignment</a>
      <a href="../playground/1.html">Playground</a>
    </div>
  </nav>
  <main>
    <header>
      <h1 class="title">Javascript</h1>
      <h2>Opdrachten 1 t/m 8</h2>
      <h1>Functions</h1>
      <hr>
    </header>
    <h2>Wat zijn functions?</h2>
    <pre class="ans">
      Functions zijn coding blocks die uitgevoerd worden. Het idee achter functies zijn het uitvoeren van specifieke taken. Er zijn aantal regels die je moet kennen om de kracht uit functies uit te halen. Door goed gebruik te maken van functies is je code veel leesbaarder.  
    </pre>
    <h2>Wat is belangrijk om mee te nemen bij het schrijven van een function ?</h2>
    <pre class="ans">
      1. Naam: Elke function die je schrijft heeft een naam. Deze naam geeft aan welke actie er uitgevoerd wordt. Door
      een goede naam aan te geven hoef je niet in code te verdiepen om te begrijpen wat het doet. Code wat werkt wil je
      het liefst zo weinig tijd aan besteden. Code begrijpen kan namelijk tijdrovend zijn, omdat je bij elke line of
      code erover gaat nadenken wat het doet. Code wordt geschreven met een bepaalde doel. Jij als ontwikkelaar wilt
      eigenlijk de doel van de code achterhalen. Als de code complex is kan het uren duren voordat je de code begrijpt.
      Door goede namen te geven begrijp je de code veel sneller.
      2. Parameters: Je kunt values meegeven aan de function. De functie kan vervolgens de value gebruiken om bepaalde
      logica uit te voeren.
      3. Return: Een function kun je aanroepen. Degene die het aanroept kan ook een waarde terugkrijgen van de function.
      De waarde is vaak de resultaat van de taak die de function heeft uitgevoerd.
    </pre>
    <h3>Leerdoelen</h3>
    <ul>
      <li>Function names</li>
      <li>Parameters</li>
      <li>Arrow functions</li>
      <li>Returns</li>
    </ul>
    <hr>
    <pre class="qn">
      Opdrachten 
      Voor de opdrachten kunnen deelnemers VisualStudio code gebruiken om de opdrachten uit te voeren. 
      
      Deze opdrachten zijn bedoeld om hands on ervaring op te bouwen. 
      
      Prerequisites 
      Maak een nieuwe html bestand aan in VSCode. Copy de volgende code in jouw html bestand. 
    </pre>

    <div class="browser">
      <p id="answer"></p>
      <button onclick="answer()">click</button>
    </div>
  </main>

  <pre class="qn">
    Opdracht 1: 
    Schrijf een functie die de tekst “hello world” in de console uitprint. Geef een goede functie naam ervoor.  
  </pre>
  <pre class="ans">
      Een javascript function wordt altijd geschreven in lowerCamelCase vorm, geef de functions altijd logische namen.
  </pre>
  <h3>Code</h3>
  <pre class="code js">
    function greetWorld() {
      console.log("hello world");
    }
  </pre>
  <p class="note"><strong>console.log()</strong>
    De <strong>console.log()</strong> <i>method</i> stuurt een bericht naar de webconsole. Het bericht kan een <i>single
      string</i> zijn (met optionele vervangingswaarden), of het kan een of meer JavaScript-objecten zijn.
    Het wordt gebruikt als <i>debugging tool</i>.
  </p>
  <hr>
  <pre class="qn">
    Opdracht 2: 
    Schrijf een functie waarbij je een tekst mee kan geven aan de functie. Print vervolgens de tekst uit in de console. 
  </pre>
  <pre class="ans">
      Onderstaand een voorbeeld van de code.
  </pre>
  <h3>Code</h3>
  <pre class="code js">
    text = "That which does not kill us makes us stronger.";

    function printText() {
      console.log(text)
    }
  </pre>
  <hr>
  <pre class="qn">
    Opdracht 3: 
    Schrijf een functie waarbij je een getal mee kan geven aan de functie. Print vervolgens het getal uit in de console. 
  </pre>
  <pre class="ans">
      Onderstaand de code, <strong>Number</strong> is een <i>primitive wrapper object</i>
  </pre>
  <h3>Code</h3>
  <pre class="code js">
    function printNumber(Number) {
      console.log(Number);
    }
  </pre>
  <p class="note">Except for null and undefined, all primitive values have object equivalents that wrap around the
    primitive values:</p>
  <ul>
    <li>
      <strong>String</strong> voor de string primitive
    </li>
    <li>
      <strong>Number</strong> voor de number primitive
    </li>
    <li>
      <strong>BigInt</strong> voor de BigInt primitive
    </li>
    <li>
      <strong>Boolean</strong> voor de boolean primitive
    </li>
    <li>
      <strong>Symbol</strong> voor de symbol primitive
    </li>
  </ul>
  <pre class="ans">
    Opdracht 4: 
    Schrijf een functie die twee getallen met elkaar vermenigvuldigt en geef de waarde van de vermenigvuldiging terug. Geef een goede functie naam ervoor. 
  </pre>
  <pre class="ans">
    De <strong>function</strong> geeft het resulaat terug met de <strong>return</strong> function en heeft twee <i>parameters</i>.
  </pre>
  <h3>Code</h3>
  <pre class="code js">
    function multiPlier(x,y) {
      return (x*y);
    }
  </pre>
  <p class="note">
    De <strong>return</strong> function beëindigt de uitvoering van de <i>function</i> en specificeert een waarde die
    naar de <i>function caller</i> moet worden geretourneerd.
  </p>
  <pre class="syntax">return [[expression]]; </pre>
  <pre class="ans">
    De <i>expression</i> waarvan de waarde moet worden geretourneerd. Indien weggelaten, wordt in plaats daarvan
    <i>undefined</i> geretourneerd.</pre>
  <hr>
  <pre class="qn">
    Opdracht 5: 
    Schrijf een functie waarbij je een naam kan meegeven aan de functie. De functie moet vervolgens controleren of de naam een bekende is.  
    
    De namen die bekend zijn: 
    ●	John 
    ●	Olly 
    ●	Mo 
    ●	Hendrik 
    ●	Tony 
    
    Als het een bekende is, dan toon je het volgende tekst op het scherm: “Dit is een bekende van ons: &#60; naam die je aan de functie hebt meegegeven&#62;”.  
    Als het niet een bekende is, dan toon je het volgende tekst op het scherm “Onbekend in ons systeem!”  
    
    We gaan de applicatie uitbreiden! Je hebt een functie geschreven waarbij je zelf een naam meegeeft aan de functie. Nu willen we dat de naam random gekozen wordt. We gaan gebruik maken van Math.random() en Math.round() functie. Lees je goed in wat beide functies doet. 
    
    Schrijf nu een functie die een random naam teruggeeft. Math.random() geeft een getal terug. 
    Zorg ervoor dat getal en naam samenhang hebben. Bijvoorbeeld getal 1 geeft aan dat het “John” is. Hieronder zie je de getallen en de namen die samenhang met elkaar hebben. 
    ●	1 = John 
    ●	2 = Oly
    ●	3 = Mo 
    ●	4 = Hendrik 
    ●	5 = Tony 
    ●	6 = Irus 
    ●	7 = Jan 
    ●	8 = Peter 
    
    Maak een functie die een random naam teruggeeft. Deze naam geef je vervolgens door aan de functie die je voorheen hebt geschreven om te controleren of de naam een bekende is van ons. 
  </pre>
  <pre class="ans">
    In plaats van een <i>if</i> statement is de switch statement gebruikt voor de <i>function searchName</i>. 
    Voor de <strong>randomName function</strong> zijn de namen opgeslagen  in een <strong>array</strong> in een <strong>const</strong> genaamd <i>names</i>.
    Om een willekeurige naam terug te geven van deze array is voor de willekeurig zoeken op indexering gebruik gemaakt van <strong>Math.random</strong> om een <i>at random</i> <i>float</i> te retourneren.
    <strong>Math.round</strong> wordt gebruikt om de <i>float</i> af te ronden naar een heel getal.
  </pre>
  <h3>Code</h3>
  <pre class="code js">
    function knownName(name) {
      switch (name) {
        case 'John':
        case 'Olly':
        case 'Mo':
        case 'Hendrik':
        case 'Tony':
          return `Dit is een bekende van ons: ${name}`;
        default:
          return "Onbekend in ons systeem!";
      }
    }
    function randomName() {
      const names = ["John", "Oly", "Mo", "Hendrik", "Tony", "Irus", "Jan", "Peter"];
      return names[Math.round(Math.random() * names.length)];
    }
  </pre>
  <p class="note"><strong>string interpolation</strong> in javascript wordt gebruikk gemaakt van `` <i>backticks</i> en
    vervolgens interpoleer je met <strong>${"<i>expression</i>"}</strong></p>
  <pre class="syntax">
    `string text`

    `string text line 1`
    `string text line 2`

    `string text ${expression} string text`

    tag`string text ${expression} string text`
  </pre>

  <hr>
  <pre class="qn">
    Opdracht 6: Arrow functions 
    De functies die kunnen ook met arrow functions geschreven worden. Herschrijf opdracht 5 zodat arrow functions gebruikt wordt. 
  </pre>
  <pre class="ans">
    Er zijn een paar arrow functions uitgeschreven met een paar verschillende expressies; <strong>switch</strong><i>statement</i>, <strong>if..else</strong><i>statements</i>, <strong>Array.includes()</strong>.
    Ze zijn geschreven in zowel de ES5 notatie <strong>function</strong> als de nieuwere ES6 notatie <strong>arrow function</strong>.
  </pre>
  <h3>Code</h3>
  <pre class="code js">
    let storedName = (name) => {
      switch (name) {
        case 'John':
        case 'Olly':
        case 'Mo':
        case 'Hendrik':
        case 'Tony':
          return `Dit is een bekende van ons: ${name}`;
        default:
          return "Onbekend in ons systeem!";
      }
    }

    function knownName(name) {
      switch (name) {
        case 'John':
        case 'Olly':
        case 'Mo':
        case 'Hendrik':
        case 'Tony':
          return `Dit is een bekende van ons: ${name}`;
        default:
          return "Onbekend in ons systeem!";
      }
    }

    function includeName(name) {
      const names = ["John", "Olly", "Mo", "Hendrik", "Tony"];
      let includedName = names.includes(name);
      if (includedName) {
        return `Dit is een bekende van ons: ${name}`;
      }
      else {
        return `Onbekend in ons systeem! ${name}`;
      }
    }

    const includeNameES6 = (name) => {
      const names = ["John", "Olly", "Mo", "Hendrik", "Tony"];
      let includedName = names.includes(name);
      if (includedName) {
        return `Dit is een bekende van ons: ${name}`;
      }
      else {
        return `Onbekend in ons systeem! ${name}`;
      }
    }

    function randomName() {
      const names = ["John", "Oly", "Mo", "Hendrik", "Tony", "Irus", "Jan", "Peter"];
      return names[Math.round(Math.random() * names.length)];
    }

    const randomNameES6 = () => {
      const names = ["John", "Oly", "Mo", "Hendrik", "Tony", "Irus", "Jan", "Peter"];
      return names[Math.round(Math.random() * names.length)];
    }

    function assignmentFive() {
      return includeName(randomName());
    }

    const assignmentFiveES6 = () => includeNameES6(randomNameES6());
  </pre>
  <p class="note">
    <strong>return</strong> <i>statement</i> eindigt de <i>function</i> uitvoering en geeft een een <i>value</i> terug
    aan de <i>function caller</i>. Javascript doet geen automatische <i>returns</i> wat wel het geval is bij Ruby.
  </p>
  <pre class="syntax">return [[expression]]; </pre>
  <h3>.includes()</h3>
  <pre class="ans">
    <strong>includes()</strong> <i>method</i> bepaalt of een array een bepaalde <i>value</i> tussen de items bevat, <i>returns</i> <strong>true</strong> en <strong>false</strong> waarbij het van toepassing is.
  </pre>
  <pre class="syntax"></pre>
  <h3>arrow function expression</h3>
  <pre class="ans">
    Een <strong>arrow function expression</strong> is een compacte alternatief van een traditionele <strong>function expression</strong>, maar het is gelimiteerder en can niet gebruikt worden in alle situaties.
  </pre>
  <h3>De verschillen & limitaties</h3>
  <ul>
    <li>
      Heeft geen eigen <i>bindings</i> met <strong>this</strong> of <strong>super</strong>, en mag niet als methode worden gebruikt.</li>
    <li>
      Heeft geen argumenten of <strong>new.target</strong> <i>keywords</i>
    </li>
    <li>
      Niet geschikt voor <strong>call</strong>, <strong>apply</strong> en <strong>bind</strong> methoden, die doorgaans afhankelijk zijn van het vaststellen van een scope.
    </li>
    <li>
      Kan niet gebruikt worden als <strong>constructor</strong>.
    </li>
    <li>
      <strong>yield</strong> kan niet gebruikt worden binnen de <i>body</i>
    </li>
  </ul>
  <h3>Basic syntax</h3>
  <p class="note">1 param. Met een eenvoudige uitdrukking is terugkeer niet nodig:</p>
  <pre class="syntax">
    param => expression
  </pre>
  <p class="note">Multiple params require parentheses. With simple expression return is not needed:</p>
  <pre class="syntax">(param1, paramN) => expression</pre>
  <p class="note">Multiline statements require <i>body brackets</i> and <i>return</i>:</p>
  <pre class="syntax">
    param => {
      let a = 1;
      return a + param1;
    }
  </pre>
  <p class="note">Meerder parameters vereisen <i>parantheses</i> <strong>()</strong>. <i>Multiline statements</i> versien <i>body brackets en de <strong>return</strong> statement</i></p>
  <hr>
  <h3>Advanced syntax</h3>
  <p class="note">To return an object literal expression requires parentheses around expression:</p>
  <pre class="syntax">params => ({foo: "a"}) // returning the object {foo: "a"}</pre>
  <p class="note">Rest parameters are supported:</p>
  <pre class="syntax">(a, b, ...r) => expression</pre>
  <p class="note">Default parameters are supported:</p>
  <pre class="syntax">(a=400, b=20, c) => expression</pre>
  <p class="note">Destructuring within params supported:</p>
  <pre class="syntax">
    ([a, b] = [10, 20]) => a + b;  // result is 30
    ({ a, b } = { a: 10, b: 20 }) => a + b; // result is 30
  </pre>
  <hr>

  <pre class="qn">
    Opdracht 7: 
    Hoe geef je 2 of meer parameters mee aan een functie? Geef een voorbeeld. 
    Wat zijn rest parameters? Geef een voorbeeld. 
    Wat is het verschil tussen rest parameters en expliciete parameters die je aangeeft bij een functie? 
  </pre>
  <pre class="ans">
    Op de onderstaande manier is een simpele voorbeeld van een arrow function met twee params.
  </pre>
  <pre class="code js">
    const f = (x, y) => x * y;
  </pre>
  <p class="note">Er zijn geen <i>brackets</i> en geen <i>return</i> statement</p>
  <pre class="ans"><strong>rest parameters</strong> syntax geeft de mogelijkheid om oneindige aantallen van argumenten mee te geven in de vorm van een array</pre>
  <pre class="code js">
    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
  </pre>
  <pre class="ans">
    Er zijn drie belangrijke verschillen tussen restparameters en het arguments-object (<i>expliciete parameters</i>):
  </pre>
  <ul>
    <li>
      <i>rest parameters</i> zijn alleen degene die geen aparte naam hebben gekregen (d.w.z. formeel gedefinieerd in <i>function</i> ), terwijl het <i>arguments-object</i> alle argumenten bevat die aan de functie zijn doorgegeven;
    </li>
    <li>
      de <i>expliciete params</i> (arguments-object) is geen array, <i>rest parameters</i> zijn  wel <i>array objects</i>
      dat houdt in dat array methods zoals <strong>sort</strong>, <strong>map</strong>, <strong>forEach</strong> of <strong>pop</strong> wel direct toepasbaar zijn.
    </li>
    <li>
      de <i>arguments</i> object heeft zijn eigen specifieke aanvullende functionaliteit, zoals de <strong>callee</strong> <i>property</i>
    </li>
  </ul>
  <h3>Rest parameters</h3>
  <pre class="syntax">
    function f(a, b, ...theArgs) {
      // ...
    }
  </pre>
  <p class="note">
    De laatste parameter van een functie kan worden voorafgegaan door <strong>...</strong> waardoor alle resterende (door de gebruiker geleverde) argumenten in een "standaard" JavaScript-array worden geplaatst. Alleen de laatste parameter kan een "restparameter" zijn.
  </p>
  <hr>

  <pre class="qn">
    Opdracht 8: Student grades! 
    Maak een nieuwe HTML bestand aan.  
    
    Wij gaan een applicatie maken om de cijfers van de studenten bij te houden. De leraar wilt op een pagina de cijfers kunnen invullen en controleren of de studenten over kunnen gaan naar de volgende klas. Met deze applicatie zorg je ervoor dat de leraar niet handmatig hoeft te berekenen wat de gemiddelde cijfers zijn per student. Hiermee heeft de leraar een compleet overzicht van de studenten. Dat scheelt tijd voor de leraar! 
  </pre>

  <div class="browser">
    <div class="flex-wrap">
      <h1>Wiskunde</h1>
    </div>
  </div>

  <footer>
    <a href="#up"></a>
  </footer>

  <script>
    function greetWorld() {
      console.log("hello world");
    }

    let text = "That which does not kill us makes us stronger.";

    function printText(text) {
      console.log(text)
    }

    function printNumber(number) {
      console.log(number);
    }

    function multiPlier(x, y) {
      return (x * y);
    }

    let storedName = (name) => {
      switch (name) {
        case 'John':
        case 'Olly':
        case 'Mo':
        case 'Hendrik':
        case 'Tony':
          return `Dit is een bekende van ons: ${name}`;
        default:
          return "Onbekend in ons systeem!";
      }
    }

    function knownName(name) {
      switch (name) {
        case 'John':
        case 'Olly':
        case 'Mo':
        case 'Hendrik':
        case 'Tony':
          return `Dit is een bekende van ons: ${name}`;
        default:
          return "Onbekend in ons systeem!";
      }
    }

    function includeName(name) {
      const names = ["John", "Olly", "Mo", "Hendrik", "Tony"];
      let includedName = names.includes(name);
      if (includedName) {
        return `Dit is een bekende van ons: ${name}`;
      }
      else {
        return `Onbekend in ons systeem! ${name}`;
      }
    }

    const includeNameES6 = (name) => {
      const names = ["John", "Olly", "Mo", "Hendrik", "Tony"];
      let includedName = names.includes(name);
      if (includedName) {
        return `Dit is een bekende van ons: ${name}`;
      }
      else {
        return `Onbekend in ons systeem! ${name}`;
      }
    }

    function randomName() {
      const names = ["John", "Oly", "Mo", "Hendrik", "Tony", "Irus", "Jan", "Peter"];
      return names[Math.round(Math.random() * names.length)];
    }

    const randomNameES6 = () => {
      const names = ["John", "Oly", "Mo", "Hendrik", "Tony", "Irus", "Jan", "Peter"];
      return names[Math.round(Math.random() * names.length)];
    }

    function assignmentFive() {
      return includeName(randomName());
    }

    const assignmentFiveES6 = () => includeNameES6(randomNameES6());

    const f = (x, y) => x * y;

    function sum(...theArgs) {
    return theArgs.reduce((previous, current) => {
      return previous + current;
    });
  }
  </script>
</body>

</html>